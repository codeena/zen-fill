<script>
        const isMobile = window.innerWidth < 768;
        let speed = isMobile ? 8.5 : 6.0; 
        const ballRad = isMobile ? 10 : 6; 
        const target = isMobile ? 750 : 1500; 
        const ringRad = 350;
    
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 800; canvas.height = 800;
    
        let balls = [];
        let rotation = 0;
        let isRunning = false;
        let isBlasted = false;
        let gameStarted = false;
        let lastBallSound = 0;
        let wakeLock = null;

        document.getElementById('score-box').innerText = "0 / " + target;
    
        // --- AUDIO ENGINE ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioCtx.createGain();
        masterGain.connect(audioCtx.destination);
        masterGain.gain.value = 0.6;
    
        function playSfx(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(masterGain);
            const now = audioCtx.currentTime;
    
            if (type === 'wall') {
                osc.frequency.setValueAtTime(220, now);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'ball') {
                if (Date.now() - lastBallSound < 35) return;
                lastBallSound = Date.now();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(700, now);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'exit') {
                osc.frequency.setValueAtTime(950, now);
                gain.gain.setValueAtTime(0.25, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            }
        }
    
        // --- TAB VISIBILITY LOGIC ---
        document.addEventListener("visibilitychange", () => {
            if (document.hidden && isRunning && gameStarted && !isBlasted) {
                pauseGame();
            }
        });

        // --- WAKE LOCK (KEEP SCREEN ON) ---
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                }
            } catch (err) { console.log("WakeLock error"); }
        }

        // --- AD & START LOGIC ---
        function requestAd(type) {
            const loadingDiv = document.getElementById('ad-loading');
            const timerText = document.getElementById('timer-text');
            const skipBtn = document.getElementById('skip-ad-btn');
            
            loadingDiv.style.display = 'flex';
            skipBtn.style.display = 'none';
            
            let timeLeft = 6;
            let countdown = setInterval(() => {
                timeLeft--;
                if (timeLeft > 0) {
                    timerText.innerText = "Connecting to Ad Server (" + timeLeft + "s)...";
                } else {
                    timerText.innerText = "Ad server not responding...";
                    skipBtn.style.display = "block"; 
                    clearInterval(countdown);
                }
            }, 1000);
    
            adBreak({
                type: type,
                name: 'game_start',
                beforeReward: (show) => { show(); },
                adViewed: () => { clearInterval(countdown); startGame(); },
                adDismissed: () => { clearInterval(countdown); startGame(); },
                adBreakDone: () => { clearInterval(countdown); if (!gameStarted) startGame(); }
            });
        }
    
        function startGame() {
            if (gameStarted) return;
            gameStarted = true;
            requestWakeLock();
            document.getElementById('ad-loading').style.display = 'none';
            document.getElementById('ui-overlay').style.display = 'none';
            document.getElementById('controls').style.display = "flex"; 
            if (balls.length === 0) balls.push({x:400, y:300, vx:speed, vy:speed, color:'#00ffff', inside:true});
            isRunning = true;
            requestAnimationFrame(animate);
        }
    
        // --- PHYSICS & RENDERING ---
        function resolveCollision(b1, b2) {
            const dx = b2.x - b1.x;
            const dy = b2.y - b1.y;
            const distanceSq = dx * dx + dy * dy;
            const minDistance = ballRad * 2;
            if (distanceSq < minDistance * minDistance && distanceSq > 0) {
                playSfx('ball');
                const distance = Math.sqrt(distanceSq);
                const overlap = (minDistance - distance) / 2;
                const nx = dx / distance; const ny = dy / distance;
                b1.x -= nx * overlap; b1.y -= ny * overlap;
                b2.x += nx * overlap; b2.y += ny * overlap;
                const v1n = b1.vx * nx + b1.vy * ny;
                const v2n = b2.vx * nx + b2.vy * ny;
                const vDiff = v1n - v2n;
                if (vDiff > 0) {
                    b1.vx -= vDiff * nx; b1.vy -= vDiff * ny;
                    b2.vx += vDiff * nx; b2.vy += vDiff * ny;
                }
            }
        }
    
        function animate() {
            if(!isRunning && !isBlasted) return;
            ctx.fillStyle = 'black'; 
            ctx.fillRect(0, 0, 800, 800);
            if(!isBlasted) rotation += 0.015;
            let activeCount = 0;
    
            const checkStep = isMobile ? 2 : 1; 
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j += checkStep) {
                    if (balls[i].inside && balls[j].inside) resolveCollision(balls[i], balls[j]);
                }
            }
    
            for(let i = balls.length - 1; i >= 0; i--) {
                let b = balls[i];
                let magnitude = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
                if (magnitude !== 0) {
                    b.vx = (b.vx / magnitude) * speed;
                    b.vy = (b.vy / magnitude) * speed;
                }
                b.x += b.vx; b.y += b.vy;
    
                let d = Math.sqrt((b.x - 400)**2 + (b.y - 400)**2);
                if (!isBlasted && b.inside && d + ballRad > ringRad) {
                    let ang = Math.atan2(b.y - 400, b.x - 400);
                    let rel = (ang - rotation) % (Math.PI * 2);
                    if(rel < 0) rel += Math.PI * 2;
                    if(rel > 0.25) {
                        playSfx('wall');
                        let nx = (b.x - 400) / d, ny = (b.y - 400) / d;
                        let dot = b.vx * nx + b.vy * ny;
                        b.vx -= 2 * dot * nx; b.vy -= 2 * dot * ny;
                        b.x = 400 + nx * (ringRad - ballRad);
                        b.y = 400 + ny * (ringRad - ballRad);
                    } else {
                        b.inside = false;
                        playSfx('exit');
                        spawn();
                    }
                }
                if(b.inside) activeCount++;
                ctx.fillStyle = b.inside ? b.color : 'rgba(255,255,255,0.1)';
                ctx.beginPath(); ctx.arc(b.x, b.y, ballRad, 0, Math.PI * 2); ctx.fill();
                if (b.y > 1200 || b.y < -400 || b.x > 1200 || b.x < -400) balls.splice(i, 1);
            }
    
            if (!isBlasted) {
                const hue = (Date.now() / 40) % 360; 
                const neonColor = `hsl(${hue}, 100%, 65%)`;
                ctx.save(); 
                ctx.lineCap = "round"; 
                ctx.strokeStyle = `hsla(${hue}, 100%, 65%, 0.3)`;
                ctx.lineWidth = 16;
                ctx.beginPath(); ctx.arc(400, 400, ringRad, rotation + 0.25, rotation + Math.PI * 2); ctx.stroke();
                ctx.strokeStyle = neonColor;
                ctx.lineWidth = 6;
                ctx.beginPath(); ctx.arc(400, 400, ringRad, rotation + 0.25, rotation + Math.PI * 2); ctx.stroke();
                ctx.restore(); 
            }
    
            document.getElementById('score-box').innerText = activeCount + " / " + target;
            if (activeCount >= target && !isBlasted) triggerBlast();
            requestAnimationFrame(animate);
        }
    
        function spawn() {
            const colors = ['#00ffff', '#ff00ff', '#00ffaa', '#ffff00', '#ffffff'];
            const c = colors[Math.floor(Math.random()*colors.length)];
            for(let i=0; i < (Math.random() > 0.8 ? 3 : 2); i++) {
                let a = Math.random() * Math.PI * 2;
                balls.push({x: 400, y: 400, vx: Math.cos(a) * speed, vy: Math.sin(a) * speed, color: c, inside: true});
            }
        }
    
        function triggerBlast() {
            isBlasted = true;
            document.getElementById('controls').style.display = 'none'; 
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(60, audioCtx.currentTime);
            osc.connect(g); g.connect(masterGain);
            g.gain.setValueAtTime(0.3, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);
            osc.start(); osc.stop(audioCtx.currentTime + 2);
    
            balls.forEach(b => {
                let ang = Math.atan2(b.y-400, b.x-400);
                let force = 10 + Math.random() * 10;
                b.vx = Math.cos(ang) * force; b.vy = Math.sin(ang) * force;
            });
            setTimeout(() => {
                document.getElementById('ui-overlay').style.display = 'flex';
                document.getElementById('end-screen').style.display = 'block';
            }, 2000);
        }
    
        function updateSpeed(newSpeed) { speed = parseFloat(newSpeed) * 1.2; }
    
        function toggleMenu() {
            const content = document.getElementById('menu-content');
            content.style.display = (content.style.display === 'flex') ? 'none' : 'flex';
        }

        function pauseGame() {
            isRunning = false;
            document.getElementById('ui-overlay').style.display = 'flex';
            document.getElementById('pause-screen').style.display = 'block';
            document.getElementById('entry-screen').style.display = 'none';
            document.getElementById('end-screen').style.display = 'none';
            document.getElementById('pause-btn').innerText = "RESUME";
            document.getElementById('pause-btn').style.color = "#ffff00";
        }
    
        function toggleGame() {
            if (isRunning) {
                pauseGame();
            } else {
                resumeGame();
            }
        }
    
        function resumeGame() {
            document.getElementById('ui-overlay').style.display = 'none';
            document.getElementById('pause-screen').style.display = 'none';
            document.getElementById('pause-btn').innerText = "STOP";
            document.getElementById('pause-btn').style.color = "#00ffff";
            if (!isRunning) {
                isRunning = true;
                requestAnimationFrame(animate);
            }
        }
    
        function confirmRestart() {
            if (confirm("Are you sure? This will reset your score!")) location.reload();
        }
    </script>
